java 23 种设计模式

根据应用场景的不同可分为 三 大类型:
	一、创建型
		1. 抽象工厂模式
				特点: 1). 一个系统不应当依赖于产品类实例如何让被创建、组合和表达的细节，这多所有形态的工厂模式都是重要的。
					 2). 这个产品有多于一个产品族，而系统只消费其中某一族的产品。
					 3). 同属于一个产品族的产品是在一起使用的，这一约束必须在系统中的设计体现出来。（比如我们选用Intel 的主板,那么就只能选用Intel的处理器）
					 4). 系统提供一个产品类的库，所有的产品以同样的接口实现，从而使客户端不依赖于实现。
				
				优点: 1). 分离接口和实现：
							客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。客户端从具体的产品实现解耦。
					 2). 使切换产品族变得容易：
							因为一个具体的工厂实现代表是一个产品族，比如上面例子的从Intel 系列到 AMD 系列只需要切换 以下具体工厂。
				
				缺点: 1). 不太容易扩展新的产品:
							如果过需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。
					
		2. 工厂方法 （同上）
		3. 建造者模式
				特点: 建造者模式是对像的创建模式.建造模式可以将一个产品的内部表象（internal representation），与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。
					  产品的内部表像:
						一个产品常有不同的组成成分作为商品的零件，这些零件有可能是对象,也有可能不是对象，它们通常又叫做产品内部表象。不同的产品有不同的内部表象，也就是不同的零件。使用建造者模式可以使客户端
						不需要知道所生成的产品有哪些零件，每个产品的零件彼此有和不同是怎么键造出来的,以及怎么组成产品。
					  对象性质的建造
						有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的昌平使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容 、附录等部分。
						而在最起码的收件人地址得到赋值之前，这个电子邮件不饿能发送。
						有些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义，在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的过程商业逻辑,这时候，此对象相当于一个有待
						建造的产品，而对象的这些性质相当于产品的零件。建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此这些零件的建造过程往往被"外部化"到另一个称作建造者的对象里面，建造者对像返回给客户端
						的是一个全部零件都建造完毕的产品对象。
						建造这迷失利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的昌平对象。建造者模式将产品的结构和产品的零件,从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造
						过程对客户端隐藏起来，把对建造过程进行指挥的之责任和具体建造者零件的责任分割开来，达到责任划分和封装的目的。
				  
				  结构: 在这个示意性的系统里，最终产品 Product 只有两个零件，part1 和 part2.相应的建造方法也有两个：buildPart1() 和 builderPart2()、同时可以看出本模式涉及到四个角色他们分别是：
				  	   
				  	   抽象建造者（builder） 角色：
				  	   	给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者（ConcreteBuilder）角色。具体建造者类
				  	   	必须实现这个接口所要求的两种方法：一种是建造方法（buildPart1 和 builderPart2），另外一种是方法（retrieveResult）。一般来说，产品所包含的零件数目于建造方法的数目相符。
				  	   	换言之，有多少零件，就有多少相应的建造方法。
				  	   具体建造者(ConcreteBuilder) 角色：
				  	 	担任这个角色的是与应用程序紧密相关的一些类，她们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：
				  	 	1. 实现抽象建造者Builder所声明的接口，给一步一步地完成创建产品实例的操作。
				  	 	2. 在建造过程完成后，提供产品的实例。
				  	 导演者（Director） 角色：
				  	 	担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。
				  	 产品（Product） 角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。
				  	 
				  	导演者角色是与客户打交道的角色。导演者将客户端创建产品的请求划分为对各个零件的1建造请求再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，
				  	但是却不为客户端所知。
				  	一般来说,每一个产品类,就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而没有一个零件就相应地再所有的建造者角色里面有一个建造方法。 
				 使用场景: 
				 	1. 需要生成的产品对象有复杂的内部结构,每一个内部成分本身可是对象,也可以仅仅是一个对象（即产品对象）的一个组成部分。
				 	2. 需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤的建造过程,因此,如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值,使用构造者模式是一个和好的设计思想。
				 	3. 在对象创建过程中会使用到系统中的其他一些对象,这些对象在产品对象的创建过程中不易得到。 	
				 	 
				  	 
		
		4. 原型模式
				简介：原型模式属于对象的创建模式.通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是原型模式的用意。
				特点：
					原型模式要求对象实现一个可以 "克隆" 自身的接口, 这样就可以通过复制一个实例对象本身来创建一个新实例。这样一来，通过原型实例创建新的对象,就不再需要关心这个实例
					本身的类型,只要实现了克隆自身的方法,就可以通过这个方法来获取新的对象。而无需再通过new 来创建对象。
					原型模式有两种表现形式: 1).简单形式、2).登记形式，这种表现形式仅仅是原型模式的不同实现。
				1).简单形式的原型模式:
					这种新式涉及到三个角色：
					
						一、客户端（Client）角色：客户端提出创建对象的请求。
						二、抽象原型（Prototype）角色：这是一个抽象角色，通常由一个 Java 接口或 Java 抽象类实现。此角色给出所有具体原型类所需的接口。
						三、具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。
						
				2).登记形式的原型模式:
					作为原型模式的第二种形式,它多了一个原型管理器（PrototypeManager）角色,该角色的作用是：创建具有原型类的对象，并记录每一被创建的对象。
				两种新式作比较
					简单形式 和 登记形式的原型模式各有其长处短处。
					如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。
					如果要创建的原型对象数目不固定的采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端
					可以查看管理员对象是否已近由一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。
		5. 单态模式
				简介：作为对象的创建模式,单列模式确保某一个类只有一个实例,而且自行实例化并向整个系统提供这个实例。这个类成为；单列类。
				特点:
					1).单例类只能有一个实例
					2).单例类必须自己创建自己的唯一实例。
					3).单例类必须给所有其他对象提供这一实例。
		
	二、结构型
		1. 适配器模式
				简介：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
				
				适配器模式的用途：用电器作为例子，笔记本电脑的插头一般都是三相的，即使除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两级，没有地极。
				电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的装换器（适配器）就能解决此问题，这正是适配器模式所做的事情。
				
				适配器模式结构
					适配器模式有 类的适配器模式 和 对象的适配器模式 两种不同的形式。
						1). 类的适配器模式: 把适配的类的 API 转化成目标类的 API。
						2). 对象适配器模式: 与类的适配器模式一样，对象适配器模式把被适配的类的 API 转成为目标类的 API，与类的适配器模式不同的是，对象的适配器模式
							不是使用继承关系连接到一起的，而是使用委派关系连接到一起的。
				优点: 1). 更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统需要。那么通过适配器模式就可以让这些功能得到更好的复用。
					 2). 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
				缺点: 过多的使用适配器，会让系统凌乱，不容易对整体进行把握。例如，明明调用的是 A 接口，其实内部适配成了 B 接口的实现，如果不是很有必要，可以不使用适配器，
					  而是直接对系统进行重构。
			缺省式适配器（Default Adapter） 模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省式
			适配器模式在 JAVA 语言 中有着特殊应用。
				其中抽象出来的类是一个适配器类，继承适配器的类实际上借助于适配器模式达到了可选则是否实现源接口中的方法。通常的处理方法是，这个具体类要是实现所有的方法，那些
				有用的方法要有实现，那些没有用的方法也要由空的、平庸的实现。
				
				这些空的方法是一种浪费，有时也是一种混乱。除非看过这些空方法的代码，程序员可能会以为这些方法不是空的。即使他知道其中有些方法是空的，也不知道具体是哪几个方法
				是空的，哪些不是空的。
				缺省式适配器可以很好的处理这一情况。可以设计一个抽象的适配器类实现接口，此抽象类要给接口所要求的每一种方法都提供一个空的方法，此抽象类可以🔟它的子类免于被迫
				实现接口方法。
				
			总结: 适配器模式的用意: 是要改变源的接口，以便目标接口相容。
				   缺省式适配器的用意不同: 它是为了方便建议一个不平庸的适配器类而提供的一种平庸实现。	
		2. 桥接模式
		3. 组合模式
		4. 外观模式
		5. 装饰着模式
		6. 享元模式
		7. 代理模式
		
	三、行为型
		1. 责任链模式
		2. 命令模式
		3. 解释器模式
		4. 迭代模式
		5. 中介者模式
		6. 备忘录模式
		7. 观察者模式
		8. 状态模式
		9. 策略模式
	   10. 模板方法模式
	   11. 访问者模式
	   
	   
	   
	   
	   