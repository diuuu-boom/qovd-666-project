特点:(作为对象的创建模式.单利模式确保某一个类只能有一个实例,而且自行实例化并向整个系统提供这个实例,通过这种模式创建出来的类,我们称之为单例类)
	1). 单列类有且仅有一个实例;
	2). 单例类自行创建实例;
	3). 单例类创建的实例能提供整个系统使用。
	

	1. 饿汉式:
		饿汉式是一种比较形象的称谓。依然饿,那么在创建对象的实例的时候就比较着急，于是在装载类的时候就创建对象实例。
		(饿汉式是典型的空间换时间,单类装载的时候就会被创建类的实例,不管你有没有用,先创建出来,然后每次调用的时候,就不需要在判断,节省运行时间。)
	
	private static EagerSingleton instance = new EagerSingleton();
	
	2. 懒汉式:
		懒汉式是典型的时间换空间，就是每次获取实例否会进行判断,看是否需要创建实例，浪费判断的时间.如果一直没人使用就不会创建实例,节约内存空间
		(懒汉式的实例式线程安全的,这样会降低整个访问的速度,而且每次都要判断。)	
		

	双重检查加锁:
		可以使用"双重检查加锁"的方式来实现,就可以即实现线程安全,又能够使性能不受很大的影响。
		所谓"双重检查枷锁" 机制,指的是：斌不是每次进入getInstance()方法都同步,而是先不同步,进入方法后先检查实例是否存在,如果不存在才能进行下面的同步块,
		以上是第一重检查,进入同步块后,再次检查实例是否存在,如果不存在,就在同步的情况下创建一个实例，这是第二重检查.这样依赖只需要同步一次了,从而减少了多次在
		同步情况下进行判断所浪费的时间。
		
		"双重检查加锁"机制的实现会使用关键字  volatile ,他的意思是: 被 volatile 修饰的变量的值,将不会被本地线程缓存,所有对该变量的读写都是直接操作共享内存,
		从而确保多个线程能正确的处理该变量。	
		
		注意: 在java1.4 以前的版本中,很多JVM 对于volatile 关键字的实现的问题,会导致 "双重检查加锁" 的失败,因此"双重检查加锁" 机制只能用在java5及以上的版本。
		
		
		提示：由于volatile 关键字可能会屏蔽掉虚拟机中一些必要的代码优化,所以运行效率并不是很高。因此一般建议，没有特别的需要不要使用.也就是说虽然可以使用 " 双重检查加锁"
		机制来实现线程安全的简单实例,但并不建议大量采用，可以根据情况来选用。
		
		Lazy initialization holder class 模式
		这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。
		
		
		什么是类级内部类,类级内部类指的是,有 static 修改的成员式内部类。如果没有 static 修饰的成员式内部类成为对象级内部类。
		类级内部类相当于其外部类的 static 成分,它的对象与外部类对象间不存在依赖关系 ，因此可以之间创建。而对象级内部类的实例，是
		绑定在外部对象实例中的。
		类即内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员变量或者成员变量。
		类级变量
		
	3.单例和枚举
		单元素得枚举类型已经成为实现Singleton得最佳方法。用枚举来实现单例非常简单,只需要编写一个包含单个元素得枚举类型即可。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
 
		